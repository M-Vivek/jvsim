// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: logical_port.proto

#ifndef PROTOBUF_logical_5fport_2eproto__INCLUDED
#define PROTOBUF_logical_5fport_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "jvision_top.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_logical_5fport_2eproto();
void protobuf_AssignDesc_logical_5fport_2eproto();
void protobuf_ShutdownFile_logical_5fport_2eproto();

class EgressInterfaceStats;
class ForwardingClassAccounting;
class GLogicalPort;
class IngressInterfaceStats;
class LogicalInterfaceInfo;
class OperationalState;

// ===================================================================

class GLogicalPort : public ::google::protobuf::Message {
 public:
  GLogicalPort();
  virtual ~GLogicalPort();

  GLogicalPort(const GLogicalPort& from);

  inline GLogicalPort& operator=(const GLogicalPort& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GLogicalPort& default_instance();

  void Swap(GLogicalPort* other);

  // implements Message ----------------------------------------------

  inline GLogicalPort* New() const { return New(NULL); }

  GLogicalPort* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GLogicalPort& from);
  void MergeFrom(const GLogicalPort& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GLogicalPort* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .LogicalInterfaceInfo interface_info = 1;
  int interface_info_size() const;
  void clear_interface_info();
  static const int kInterfaceInfoFieldNumber = 1;
  const ::LogicalInterfaceInfo& interface_info(int index) const;
  ::LogicalInterfaceInfo* mutable_interface_info(int index);
  ::LogicalInterfaceInfo* add_interface_info();
  ::google::protobuf::RepeatedPtrField< ::LogicalInterfaceInfo >*
      mutable_interface_info();
  const ::google::protobuf::RepeatedPtrField< ::LogicalInterfaceInfo >&
      interface_info() const;

  // @@protoc_insertion_point(class_scope:GLogicalPort)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::LogicalInterfaceInfo > interface_info_;
  friend void  protobuf_AddDesc_logical_5fport_2eproto();
  friend void protobuf_AssignDesc_logical_5fport_2eproto();
  friend void protobuf_ShutdownFile_logical_5fport_2eproto();

  void InitAsDefaultInstance();
  static GLogicalPort* default_instance_;
};
// -------------------------------------------------------------------

class LogicalInterfaceInfo : public ::google::protobuf::Message {
 public:
  LogicalInterfaceInfo();
  virtual ~LogicalInterfaceInfo();

  LogicalInterfaceInfo(const LogicalInterfaceInfo& from);

  inline LogicalInterfaceInfo& operator=(const LogicalInterfaceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicalInterfaceInfo& default_instance();

  void Swap(LogicalInterfaceInfo* other);

  // implements Message ----------------------------------------------

  inline LogicalInterfaceInfo* New() const { return New(NULL); }

  LogicalInterfaceInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogicalInterfaceInfo& from);
  void MergeFrom(const LogicalInterfaceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogicalInterfaceInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string if_name = 1;
  bool has_if_name() const;
  void clear_if_name();
  static const int kIfNameFieldNumber = 1;
  const ::std::string& if_name() const;
  void set_if_name(const ::std::string& value);
  void set_if_name(const char* value);
  void set_if_name(const char* value, size_t size);
  ::std::string* mutable_if_name();
  ::std::string* release_if_name();
  void set_allocated_if_name(::std::string* if_name);

  // required uint64 init_time = 2;
  bool has_init_time() const;
  void clear_init_time();
  static const int kInitTimeFieldNumber = 2;
  ::google::protobuf::uint64 init_time() const;
  void set_init_time(::google::protobuf::uint64 value);

  // optional uint32 snmp_if_index = 3;
  bool has_snmp_if_index() const;
  void clear_snmp_if_index();
  static const int kSnmpIfIndexFieldNumber = 3;
  ::google::protobuf::uint32 snmp_if_index() const;
  void set_snmp_if_index(::google::protobuf::uint32 value);

  // optional string parent_ae_name = 4;
  bool has_parent_ae_name() const;
  void clear_parent_ae_name();
  static const int kParentAeNameFieldNumber = 4;
  const ::std::string& parent_ae_name() const;
  void set_parent_ae_name(const ::std::string& value);
  void set_parent_ae_name(const char* value);
  void set_parent_ae_name(const char* value, size_t size);
  ::std::string* mutable_parent_ae_name();
  ::std::string* release_parent_ae_name();
  void set_allocated_parent_ae_name(::std::string* parent_ae_name);

  // optional .IngressInterfaceStats ingress_stats = 5;
  bool has_ingress_stats() const;
  void clear_ingress_stats();
  static const int kIngressStatsFieldNumber = 5;
  const ::IngressInterfaceStats& ingress_stats() const;
  ::IngressInterfaceStats* mutable_ingress_stats();
  ::IngressInterfaceStats* release_ingress_stats();
  void set_allocated_ingress_stats(::IngressInterfaceStats* ingress_stats);

  // optional .EgressInterfaceStats egress_stats = 6;
  bool has_egress_stats() const;
  void clear_egress_stats();
  static const int kEgressStatsFieldNumber = 6;
  const ::EgressInterfaceStats& egress_stats() const;
  ::EgressInterfaceStats* mutable_egress_stats();
  ::EgressInterfaceStats* release_egress_stats();
  void set_allocated_egress_stats(::EgressInterfaceStats* egress_stats);

  // optional .OperationalState op_state = 7;
  bool has_op_state() const;
  void clear_op_state();
  static const int kOpStateFieldNumber = 7;
  const ::OperationalState& op_state() const;
  ::OperationalState* mutable_op_state();
  ::OperationalState* release_op_state();
  void set_allocated_op_state(::OperationalState* op_state);

  // @@protoc_insertion_point(class_scope:LogicalInterfaceInfo)
 private:
  inline void set_has_if_name();
  inline void clear_has_if_name();
  inline void set_has_init_time();
  inline void clear_has_init_time();
  inline void set_has_snmp_if_index();
  inline void clear_has_snmp_if_index();
  inline void set_has_parent_ae_name();
  inline void clear_has_parent_ae_name();
  inline void set_has_ingress_stats();
  inline void clear_has_ingress_stats();
  inline void set_has_egress_stats();
  inline void clear_has_egress_stats();
  inline void set_has_op_state();
  inline void clear_has_op_state();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr if_name_;
  ::google::protobuf::uint64 init_time_;
  ::google::protobuf::internal::ArenaStringPtr parent_ae_name_;
  ::IngressInterfaceStats* ingress_stats_;
  ::EgressInterfaceStats* egress_stats_;
  ::OperationalState* op_state_;
  ::google::protobuf::uint32 snmp_if_index_;
  friend void  protobuf_AddDesc_logical_5fport_2eproto();
  friend void protobuf_AssignDesc_logical_5fport_2eproto();
  friend void protobuf_ShutdownFile_logical_5fport_2eproto();

  void InitAsDefaultInstance();
  static LogicalInterfaceInfo* default_instance_;
};
// -------------------------------------------------------------------

class IngressInterfaceStats : public ::google::protobuf::Message {
 public:
  IngressInterfaceStats();
  virtual ~IngressInterfaceStats();

  IngressInterfaceStats(const IngressInterfaceStats& from);

  inline IngressInterfaceStats& operator=(const IngressInterfaceStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IngressInterfaceStats& default_instance();

  void Swap(IngressInterfaceStats* other);

  // implements Message ----------------------------------------------

  inline IngressInterfaceStats* New() const { return New(NULL); }

  IngressInterfaceStats* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IngressInterfaceStats& from);
  void MergeFrom(const IngressInterfaceStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IngressInterfaceStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 if_pkts = 1;
  bool has_if_pkts() const;
  void clear_if_pkts();
  static const int kIfPktsFieldNumber = 1;
  ::google::protobuf::uint64 if_pkts() const;
  void set_if_pkts(::google::protobuf::uint64 value);

  // required uint64 if_octets = 2;
  bool has_if_octets() const;
  void clear_if_octets();
  static const int kIfOctetsFieldNumber = 2;
  ::google::protobuf::uint64 if_octets() const;
  void set_if_octets(::google::protobuf::uint64 value);

  // optional uint64 if_ucast_pkts = 3;
  bool has_if_ucast_pkts() const;
  void clear_if_ucast_pkts();
  static const int kIfUcastPktsFieldNumber = 3;
  ::google::protobuf::uint64 if_ucast_pkts() const;
  void set_if_ucast_pkts(::google::protobuf::uint64 value);

  // required uint64 if_mcast_pkts = 4;
  bool has_if_mcast_pkts() const;
  void clear_if_mcast_pkts();
  static const int kIfMcastPktsFieldNumber = 4;
  ::google::protobuf::uint64 if_mcast_pkts() const;
  void set_if_mcast_pkts(::google::protobuf::uint64 value);

  // repeated .ForwardingClassAccounting if_fc_stats = 5;
  int if_fc_stats_size() const;
  void clear_if_fc_stats();
  static const int kIfFcStatsFieldNumber = 5;
  const ::ForwardingClassAccounting& if_fc_stats(int index) const;
  ::ForwardingClassAccounting* mutable_if_fc_stats(int index);
  ::ForwardingClassAccounting* add_if_fc_stats();
  ::google::protobuf::RepeatedPtrField< ::ForwardingClassAccounting >*
      mutable_if_fc_stats();
  const ::google::protobuf::RepeatedPtrField< ::ForwardingClassAccounting >&
      if_fc_stats() const;

  // @@protoc_insertion_point(class_scope:IngressInterfaceStats)
 private:
  inline void set_has_if_pkts();
  inline void clear_has_if_pkts();
  inline void set_has_if_octets();
  inline void clear_has_if_octets();
  inline void set_has_if_ucast_pkts();
  inline void clear_has_if_ucast_pkts();
  inline void set_has_if_mcast_pkts();
  inline void clear_has_if_mcast_pkts();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 if_pkts_;
  ::google::protobuf::uint64 if_octets_;
  ::google::protobuf::uint64 if_ucast_pkts_;
  ::google::protobuf::uint64 if_mcast_pkts_;
  ::google::protobuf::RepeatedPtrField< ::ForwardingClassAccounting > if_fc_stats_;
  friend void  protobuf_AddDesc_logical_5fport_2eproto();
  friend void protobuf_AssignDesc_logical_5fport_2eproto();
  friend void protobuf_ShutdownFile_logical_5fport_2eproto();

  void InitAsDefaultInstance();
  static IngressInterfaceStats* default_instance_;
};
// -------------------------------------------------------------------

class EgressInterfaceStats : public ::google::protobuf::Message {
 public:
  EgressInterfaceStats();
  virtual ~EgressInterfaceStats();

  EgressInterfaceStats(const EgressInterfaceStats& from);

  inline EgressInterfaceStats& operator=(const EgressInterfaceStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EgressInterfaceStats& default_instance();

  void Swap(EgressInterfaceStats* other);

  // implements Message ----------------------------------------------

  inline EgressInterfaceStats* New() const { return New(NULL); }

  EgressInterfaceStats* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EgressInterfaceStats& from);
  void MergeFrom(const EgressInterfaceStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EgressInterfaceStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 if_pkts = 1;
  bool has_if_pkts() const;
  void clear_if_pkts();
  static const int kIfPktsFieldNumber = 1;
  ::google::protobuf::uint64 if_pkts() const;
  void set_if_pkts(::google::protobuf::uint64 value);

  // required uint64 if_octets = 2;
  bool has_if_octets() const;
  void clear_if_octets();
  static const int kIfOctetsFieldNumber = 2;
  ::google::protobuf::uint64 if_octets() const;
  void set_if_octets(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:EgressInterfaceStats)
 private:
  inline void set_has_if_pkts();
  inline void clear_has_if_pkts();
  inline void set_has_if_octets();
  inline void clear_has_if_octets();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 if_pkts_;
  ::google::protobuf::uint64 if_octets_;
  friend void  protobuf_AddDesc_logical_5fport_2eproto();
  friend void protobuf_AssignDesc_logical_5fport_2eproto();
  friend void protobuf_ShutdownFile_logical_5fport_2eproto();

  void InitAsDefaultInstance();
  static EgressInterfaceStats* default_instance_;
};
// -------------------------------------------------------------------

class OperationalState : public ::google::protobuf::Message {
 public:
  OperationalState();
  virtual ~OperationalState();

  OperationalState(const OperationalState& from);

  inline OperationalState& operator=(const OperationalState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationalState& default_instance();

  void Swap(OperationalState* other);

  // implements Message ----------------------------------------------

  inline OperationalState* New() const { return New(NULL); }

  OperationalState* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationalState& from);
  void MergeFrom(const OperationalState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OperationalState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string operational_status = 1;
  bool has_operational_status() const;
  void clear_operational_status();
  static const int kOperationalStatusFieldNumber = 1;
  const ::std::string& operational_status() const;
  void set_operational_status(const ::std::string& value);
  void set_operational_status(const char* value);
  void set_operational_status(const char* value, size_t size);
  ::std::string* mutable_operational_status();
  ::std::string* release_operational_status();
  void set_allocated_operational_status(::std::string* operational_status);

  // @@protoc_insertion_point(class_scope:OperationalState)
 private:
  inline void set_has_operational_status();
  inline void clear_has_operational_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr operational_status_;
  friend void  protobuf_AddDesc_logical_5fport_2eproto();
  friend void protobuf_AssignDesc_logical_5fport_2eproto();
  friend void protobuf_ShutdownFile_logical_5fport_2eproto();

  void InitAsDefaultInstance();
  static OperationalState* default_instance_;
};
// -------------------------------------------------------------------

class ForwardingClassAccounting : public ::google::protobuf::Message {
 public:
  ForwardingClassAccounting();
  virtual ~ForwardingClassAccounting();

  ForwardingClassAccounting(const ForwardingClassAccounting& from);

  inline ForwardingClassAccounting& operator=(const ForwardingClassAccounting& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ForwardingClassAccounting& default_instance();

  void Swap(ForwardingClassAccounting* other);

  // implements Message ----------------------------------------------

  inline ForwardingClassAccounting* New() const { return New(NULL); }

  ForwardingClassAccounting* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ForwardingClassAccounting& from);
  void MergeFrom(const ForwardingClassAccounting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ForwardingClassAccounting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string if_family = 1;
  bool has_if_family() const;
  void clear_if_family();
  static const int kIfFamilyFieldNumber = 1;
  const ::std::string& if_family() const;
  void set_if_family(const ::std::string& value);
  void set_if_family(const char* value);
  void set_if_family(const char* value, size_t size);
  ::std::string* mutable_if_family();
  ::std::string* release_if_family();
  void set_allocated_if_family(::std::string* if_family);

  // optional uint32 fc_number = 2;
  bool has_fc_number() const;
  void clear_fc_number();
  static const int kFcNumberFieldNumber = 2;
  ::google::protobuf::uint32 fc_number() const;
  void set_fc_number(::google::protobuf::uint32 value);

  // optional uint64 if_pkts = 3;
  bool has_if_pkts() const;
  void clear_if_pkts();
  static const int kIfPktsFieldNumber = 3;
  ::google::protobuf::uint64 if_pkts() const;
  void set_if_pkts(::google::protobuf::uint64 value);

  // optional uint64 if_octets = 4;
  bool has_if_octets() const;
  void clear_if_octets();
  static const int kIfOctetsFieldNumber = 4;
  ::google::protobuf::uint64 if_octets() const;
  void set_if_octets(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ForwardingClassAccounting)
 private:
  inline void set_has_if_family();
  inline void clear_has_if_family();
  inline void set_has_fc_number();
  inline void clear_has_fc_number();
  inline void set_has_if_pkts();
  inline void clear_has_if_pkts();
  inline void set_has_if_octets();
  inline void clear_has_if_octets();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr if_family_;
  ::google::protobuf::uint64 if_pkts_;
  ::google::protobuf::uint64 if_octets_;
  ::google::protobuf::uint32 fc_number_;
  friend void  protobuf_AddDesc_logical_5fport_2eproto();
  friend void protobuf_AssignDesc_logical_5fport_2eproto();
  friend void protobuf_ShutdownFile_logical_5fport_2eproto();

  void InitAsDefaultInstance();
  static ForwardingClassAccounting* default_instance_;
};
// ===================================================================

static const int kJnprLogicalInterfaceExtFieldNumber = 7;
extern ::google::protobuf::internal::ExtensionIdentifier< ::JuniperNetworksSensors,
    ::google::protobuf::internal::MessageTypeTraits< ::GLogicalPort >, 11, false >
  jnprLogicalInterfaceExt;

// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// GLogicalPort

// repeated .LogicalInterfaceInfo interface_info = 1;
inline int GLogicalPort::interface_info_size() const {
  return interface_info_.size();
}
inline void GLogicalPort::clear_interface_info() {
  interface_info_.Clear();
}
inline const ::LogicalInterfaceInfo& GLogicalPort::interface_info(int index) const {
  // @@protoc_insertion_point(field_get:GLogicalPort.interface_info)
  return interface_info_.Get(index);
}
inline ::LogicalInterfaceInfo* GLogicalPort::mutable_interface_info(int index) {
  // @@protoc_insertion_point(field_mutable:GLogicalPort.interface_info)
  return interface_info_.Mutable(index);
}
inline ::LogicalInterfaceInfo* GLogicalPort::add_interface_info() {
  // @@protoc_insertion_point(field_add:GLogicalPort.interface_info)
  return interface_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::LogicalInterfaceInfo >*
GLogicalPort::mutable_interface_info() {
  // @@protoc_insertion_point(field_mutable_list:GLogicalPort.interface_info)
  return &interface_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::LogicalInterfaceInfo >&
GLogicalPort::interface_info() const {
  // @@protoc_insertion_point(field_list:GLogicalPort.interface_info)
  return interface_info_;
}

// -------------------------------------------------------------------

// LogicalInterfaceInfo

// required string if_name = 1;
inline bool LogicalInterfaceInfo::has_if_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogicalInterfaceInfo::set_has_if_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogicalInterfaceInfo::clear_has_if_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogicalInterfaceInfo::clear_if_name() {
  if_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_if_name();
}
inline const ::std::string& LogicalInterfaceInfo::if_name() const {
  // @@protoc_insertion_point(field_get:LogicalInterfaceInfo.if_name)
  return if_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogicalInterfaceInfo::set_if_name(const ::std::string& value) {
  set_has_if_name();
  if_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LogicalInterfaceInfo.if_name)
}
inline void LogicalInterfaceInfo::set_if_name(const char* value) {
  set_has_if_name();
  if_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LogicalInterfaceInfo.if_name)
}
inline void LogicalInterfaceInfo::set_if_name(const char* value, size_t size) {
  set_has_if_name();
  if_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LogicalInterfaceInfo.if_name)
}
inline ::std::string* LogicalInterfaceInfo::mutable_if_name() {
  set_has_if_name();
  // @@protoc_insertion_point(field_mutable:LogicalInterfaceInfo.if_name)
  return if_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogicalInterfaceInfo::release_if_name() {
  clear_has_if_name();
  return if_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogicalInterfaceInfo::set_allocated_if_name(::std::string* if_name) {
  if (if_name != NULL) {
    set_has_if_name();
  } else {
    clear_has_if_name();
  }
  if_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), if_name);
  // @@protoc_insertion_point(field_set_allocated:LogicalInterfaceInfo.if_name)
}

// required uint64 init_time = 2;
inline bool LogicalInterfaceInfo::has_init_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogicalInterfaceInfo::set_has_init_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogicalInterfaceInfo::clear_has_init_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogicalInterfaceInfo::clear_init_time() {
  init_time_ = GOOGLE_ULONGLONG(0);
  clear_has_init_time();
}
inline ::google::protobuf::uint64 LogicalInterfaceInfo::init_time() const {
  // @@protoc_insertion_point(field_get:LogicalInterfaceInfo.init_time)
  return init_time_;
}
inline void LogicalInterfaceInfo::set_init_time(::google::protobuf::uint64 value) {
  set_has_init_time();
  init_time_ = value;
  // @@protoc_insertion_point(field_set:LogicalInterfaceInfo.init_time)
}

// optional uint32 snmp_if_index = 3;
inline bool LogicalInterfaceInfo::has_snmp_if_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogicalInterfaceInfo::set_has_snmp_if_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogicalInterfaceInfo::clear_has_snmp_if_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogicalInterfaceInfo::clear_snmp_if_index() {
  snmp_if_index_ = 0u;
  clear_has_snmp_if_index();
}
inline ::google::protobuf::uint32 LogicalInterfaceInfo::snmp_if_index() const {
  // @@protoc_insertion_point(field_get:LogicalInterfaceInfo.snmp_if_index)
  return snmp_if_index_;
}
inline void LogicalInterfaceInfo::set_snmp_if_index(::google::protobuf::uint32 value) {
  set_has_snmp_if_index();
  snmp_if_index_ = value;
  // @@protoc_insertion_point(field_set:LogicalInterfaceInfo.snmp_if_index)
}

// optional string parent_ae_name = 4;
inline bool LogicalInterfaceInfo::has_parent_ae_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogicalInterfaceInfo::set_has_parent_ae_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogicalInterfaceInfo::clear_has_parent_ae_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogicalInterfaceInfo::clear_parent_ae_name() {
  parent_ae_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_parent_ae_name();
}
inline const ::std::string& LogicalInterfaceInfo::parent_ae_name() const {
  // @@protoc_insertion_point(field_get:LogicalInterfaceInfo.parent_ae_name)
  return parent_ae_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogicalInterfaceInfo::set_parent_ae_name(const ::std::string& value) {
  set_has_parent_ae_name();
  parent_ae_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LogicalInterfaceInfo.parent_ae_name)
}
inline void LogicalInterfaceInfo::set_parent_ae_name(const char* value) {
  set_has_parent_ae_name();
  parent_ae_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LogicalInterfaceInfo.parent_ae_name)
}
inline void LogicalInterfaceInfo::set_parent_ae_name(const char* value, size_t size) {
  set_has_parent_ae_name();
  parent_ae_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LogicalInterfaceInfo.parent_ae_name)
}
inline ::std::string* LogicalInterfaceInfo::mutable_parent_ae_name() {
  set_has_parent_ae_name();
  // @@protoc_insertion_point(field_mutable:LogicalInterfaceInfo.parent_ae_name)
  return parent_ae_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogicalInterfaceInfo::release_parent_ae_name() {
  clear_has_parent_ae_name();
  return parent_ae_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogicalInterfaceInfo::set_allocated_parent_ae_name(::std::string* parent_ae_name) {
  if (parent_ae_name != NULL) {
    set_has_parent_ae_name();
  } else {
    clear_has_parent_ae_name();
  }
  parent_ae_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent_ae_name);
  // @@protoc_insertion_point(field_set_allocated:LogicalInterfaceInfo.parent_ae_name)
}

// optional .IngressInterfaceStats ingress_stats = 5;
inline bool LogicalInterfaceInfo::has_ingress_stats() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LogicalInterfaceInfo::set_has_ingress_stats() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LogicalInterfaceInfo::clear_has_ingress_stats() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LogicalInterfaceInfo::clear_ingress_stats() {
  if (ingress_stats_ != NULL) ingress_stats_->::IngressInterfaceStats::Clear();
  clear_has_ingress_stats();
}
inline const ::IngressInterfaceStats& LogicalInterfaceInfo::ingress_stats() const {
  // @@protoc_insertion_point(field_get:LogicalInterfaceInfo.ingress_stats)
  return ingress_stats_ != NULL ? *ingress_stats_ : *default_instance_->ingress_stats_;
}
inline ::IngressInterfaceStats* LogicalInterfaceInfo::mutable_ingress_stats() {
  set_has_ingress_stats();
  if (ingress_stats_ == NULL) {
    ingress_stats_ = new ::IngressInterfaceStats;
  }
  // @@protoc_insertion_point(field_mutable:LogicalInterfaceInfo.ingress_stats)
  return ingress_stats_;
}
inline ::IngressInterfaceStats* LogicalInterfaceInfo::release_ingress_stats() {
  clear_has_ingress_stats();
  ::IngressInterfaceStats* temp = ingress_stats_;
  ingress_stats_ = NULL;
  return temp;
}
inline void LogicalInterfaceInfo::set_allocated_ingress_stats(::IngressInterfaceStats* ingress_stats) {
  delete ingress_stats_;
  ingress_stats_ = ingress_stats;
  if (ingress_stats) {
    set_has_ingress_stats();
  } else {
    clear_has_ingress_stats();
  }
  // @@protoc_insertion_point(field_set_allocated:LogicalInterfaceInfo.ingress_stats)
}

// optional .EgressInterfaceStats egress_stats = 6;
inline bool LogicalInterfaceInfo::has_egress_stats() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LogicalInterfaceInfo::set_has_egress_stats() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LogicalInterfaceInfo::clear_has_egress_stats() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LogicalInterfaceInfo::clear_egress_stats() {
  if (egress_stats_ != NULL) egress_stats_->::EgressInterfaceStats::Clear();
  clear_has_egress_stats();
}
inline const ::EgressInterfaceStats& LogicalInterfaceInfo::egress_stats() const {
  // @@protoc_insertion_point(field_get:LogicalInterfaceInfo.egress_stats)
  return egress_stats_ != NULL ? *egress_stats_ : *default_instance_->egress_stats_;
}
inline ::EgressInterfaceStats* LogicalInterfaceInfo::mutable_egress_stats() {
  set_has_egress_stats();
  if (egress_stats_ == NULL) {
    egress_stats_ = new ::EgressInterfaceStats;
  }
  // @@protoc_insertion_point(field_mutable:LogicalInterfaceInfo.egress_stats)
  return egress_stats_;
}
inline ::EgressInterfaceStats* LogicalInterfaceInfo::release_egress_stats() {
  clear_has_egress_stats();
  ::EgressInterfaceStats* temp = egress_stats_;
  egress_stats_ = NULL;
  return temp;
}
inline void LogicalInterfaceInfo::set_allocated_egress_stats(::EgressInterfaceStats* egress_stats) {
  delete egress_stats_;
  egress_stats_ = egress_stats;
  if (egress_stats) {
    set_has_egress_stats();
  } else {
    clear_has_egress_stats();
  }
  // @@protoc_insertion_point(field_set_allocated:LogicalInterfaceInfo.egress_stats)
}

// optional .OperationalState op_state = 7;
inline bool LogicalInterfaceInfo::has_op_state() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LogicalInterfaceInfo::set_has_op_state() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LogicalInterfaceInfo::clear_has_op_state() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LogicalInterfaceInfo::clear_op_state() {
  if (op_state_ != NULL) op_state_->::OperationalState::Clear();
  clear_has_op_state();
}
inline const ::OperationalState& LogicalInterfaceInfo::op_state() const {
  // @@protoc_insertion_point(field_get:LogicalInterfaceInfo.op_state)
  return op_state_ != NULL ? *op_state_ : *default_instance_->op_state_;
}
inline ::OperationalState* LogicalInterfaceInfo::mutable_op_state() {
  set_has_op_state();
  if (op_state_ == NULL) {
    op_state_ = new ::OperationalState;
  }
  // @@protoc_insertion_point(field_mutable:LogicalInterfaceInfo.op_state)
  return op_state_;
}
inline ::OperationalState* LogicalInterfaceInfo::release_op_state() {
  clear_has_op_state();
  ::OperationalState* temp = op_state_;
  op_state_ = NULL;
  return temp;
}
inline void LogicalInterfaceInfo::set_allocated_op_state(::OperationalState* op_state) {
  delete op_state_;
  op_state_ = op_state;
  if (op_state) {
    set_has_op_state();
  } else {
    clear_has_op_state();
  }
  // @@protoc_insertion_point(field_set_allocated:LogicalInterfaceInfo.op_state)
}

// -------------------------------------------------------------------

// IngressInterfaceStats

// required uint64 if_pkts = 1;
inline bool IngressInterfaceStats::has_if_pkts() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IngressInterfaceStats::set_has_if_pkts() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IngressInterfaceStats::clear_has_if_pkts() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IngressInterfaceStats::clear_if_pkts() {
  if_pkts_ = GOOGLE_ULONGLONG(0);
  clear_has_if_pkts();
}
inline ::google::protobuf::uint64 IngressInterfaceStats::if_pkts() const {
  // @@protoc_insertion_point(field_get:IngressInterfaceStats.if_pkts)
  return if_pkts_;
}
inline void IngressInterfaceStats::set_if_pkts(::google::protobuf::uint64 value) {
  set_has_if_pkts();
  if_pkts_ = value;
  // @@protoc_insertion_point(field_set:IngressInterfaceStats.if_pkts)
}

// required uint64 if_octets = 2;
inline bool IngressInterfaceStats::has_if_octets() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IngressInterfaceStats::set_has_if_octets() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IngressInterfaceStats::clear_has_if_octets() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IngressInterfaceStats::clear_if_octets() {
  if_octets_ = GOOGLE_ULONGLONG(0);
  clear_has_if_octets();
}
inline ::google::protobuf::uint64 IngressInterfaceStats::if_octets() const {
  // @@protoc_insertion_point(field_get:IngressInterfaceStats.if_octets)
  return if_octets_;
}
inline void IngressInterfaceStats::set_if_octets(::google::protobuf::uint64 value) {
  set_has_if_octets();
  if_octets_ = value;
  // @@protoc_insertion_point(field_set:IngressInterfaceStats.if_octets)
}

// optional uint64 if_ucast_pkts = 3;
inline bool IngressInterfaceStats::has_if_ucast_pkts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IngressInterfaceStats::set_has_if_ucast_pkts() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IngressInterfaceStats::clear_has_if_ucast_pkts() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IngressInterfaceStats::clear_if_ucast_pkts() {
  if_ucast_pkts_ = GOOGLE_ULONGLONG(0);
  clear_has_if_ucast_pkts();
}
inline ::google::protobuf::uint64 IngressInterfaceStats::if_ucast_pkts() const {
  // @@protoc_insertion_point(field_get:IngressInterfaceStats.if_ucast_pkts)
  return if_ucast_pkts_;
}
inline void IngressInterfaceStats::set_if_ucast_pkts(::google::protobuf::uint64 value) {
  set_has_if_ucast_pkts();
  if_ucast_pkts_ = value;
  // @@protoc_insertion_point(field_set:IngressInterfaceStats.if_ucast_pkts)
}

// required uint64 if_mcast_pkts = 4;
inline bool IngressInterfaceStats::has_if_mcast_pkts() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IngressInterfaceStats::set_has_if_mcast_pkts() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IngressInterfaceStats::clear_has_if_mcast_pkts() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IngressInterfaceStats::clear_if_mcast_pkts() {
  if_mcast_pkts_ = GOOGLE_ULONGLONG(0);
  clear_has_if_mcast_pkts();
}
inline ::google::protobuf::uint64 IngressInterfaceStats::if_mcast_pkts() const {
  // @@protoc_insertion_point(field_get:IngressInterfaceStats.if_mcast_pkts)
  return if_mcast_pkts_;
}
inline void IngressInterfaceStats::set_if_mcast_pkts(::google::protobuf::uint64 value) {
  set_has_if_mcast_pkts();
  if_mcast_pkts_ = value;
  // @@protoc_insertion_point(field_set:IngressInterfaceStats.if_mcast_pkts)
}

// repeated .ForwardingClassAccounting if_fc_stats = 5;
inline int IngressInterfaceStats::if_fc_stats_size() const {
  return if_fc_stats_.size();
}
inline void IngressInterfaceStats::clear_if_fc_stats() {
  if_fc_stats_.Clear();
}
inline const ::ForwardingClassAccounting& IngressInterfaceStats::if_fc_stats(int index) const {
  // @@protoc_insertion_point(field_get:IngressInterfaceStats.if_fc_stats)
  return if_fc_stats_.Get(index);
}
inline ::ForwardingClassAccounting* IngressInterfaceStats::mutable_if_fc_stats(int index) {
  // @@protoc_insertion_point(field_mutable:IngressInterfaceStats.if_fc_stats)
  return if_fc_stats_.Mutable(index);
}
inline ::ForwardingClassAccounting* IngressInterfaceStats::add_if_fc_stats() {
  // @@protoc_insertion_point(field_add:IngressInterfaceStats.if_fc_stats)
  return if_fc_stats_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ForwardingClassAccounting >*
IngressInterfaceStats::mutable_if_fc_stats() {
  // @@protoc_insertion_point(field_mutable_list:IngressInterfaceStats.if_fc_stats)
  return &if_fc_stats_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ForwardingClassAccounting >&
IngressInterfaceStats::if_fc_stats() const {
  // @@protoc_insertion_point(field_list:IngressInterfaceStats.if_fc_stats)
  return if_fc_stats_;
}

// -------------------------------------------------------------------

// EgressInterfaceStats

// required uint64 if_pkts = 1;
inline bool EgressInterfaceStats::has_if_pkts() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EgressInterfaceStats::set_has_if_pkts() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EgressInterfaceStats::clear_has_if_pkts() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EgressInterfaceStats::clear_if_pkts() {
  if_pkts_ = GOOGLE_ULONGLONG(0);
  clear_has_if_pkts();
}
inline ::google::protobuf::uint64 EgressInterfaceStats::if_pkts() const {
  // @@protoc_insertion_point(field_get:EgressInterfaceStats.if_pkts)
  return if_pkts_;
}
inline void EgressInterfaceStats::set_if_pkts(::google::protobuf::uint64 value) {
  set_has_if_pkts();
  if_pkts_ = value;
  // @@protoc_insertion_point(field_set:EgressInterfaceStats.if_pkts)
}

// required uint64 if_octets = 2;
inline bool EgressInterfaceStats::has_if_octets() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EgressInterfaceStats::set_has_if_octets() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EgressInterfaceStats::clear_has_if_octets() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EgressInterfaceStats::clear_if_octets() {
  if_octets_ = GOOGLE_ULONGLONG(0);
  clear_has_if_octets();
}
inline ::google::protobuf::uint64 EgressInterfaceStats::if_octets() const {
  // @@protoc_insertion_point(field_get:EgressInterfaceStats.if_octets)
  return if_octets_;
}
inline void EgressInterfaceStats::set_if_octets(::google::protobuf::uint64 value) {
  set_has_if_octets();
  if_octets_ = value;
  // @@protoc_insertion_point(field_set:EgressInterfaceStats.if_octets)
}

// -------------------------------------------------------------------

// OperationalState

// optional string operational_status = 1;
inline bool OperationalState::has_operational_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationalState::set_has_operational_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationalState::clear_has_operational_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationalState::clear_operational_status() {
  operational_status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_operational_status();
}
inline const ::std::string& OperationalState::operational_status() const {
  // @@protoc_insertion_point(field_get:OperationalState.operational_status)
  return operational_status_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationalState::set_operational_status(const ::std::string& value) {
  set_has_operational_status();
  operational_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:OperationalState.operational_status)
}
inline void OperationalState::set_operational_status(const char* value) {
  set_has_operational_status();
  operational_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:OperationalState.operational_status)
}
inline void OperationalState::set_operational_status(const char* value, size_t size) {
  set_has_operational_status();
  operational_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:OperationalState.operational_status)
}
inline ::std::string* OperationalState::mutable_operational_status() {
  set_has_operational_status();
  // @@protoc_insertion_point(field_mutable:OperationalState.operational_status)
  return operational_status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationalState::release_operational_status() {
  clear_has_operational_status();
  return operational_status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationalState::set_allocated_operational_status(::std::string* operational_status) {
  if (operational_status != NULL) {
    set_has_operational_status();
  } else {
    clear_has_operational_status();
  }
  operational_status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), operational_status);
  // @@protoc_insertion_point(field_set_allocated:OperationalState.operational_status)
}

// -------------------------------------------------------------------

// ForwardingClassAccounting

// optional string if_family = 1;
inline bool ForwardingClassAccounting::has_if_family() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ForwardingClassAccounting::set_has_if_family() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ForwardingClassAccounting::clear_has_if_family() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ForwardingClassAccounting::clear_if_family() {
  if_family_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_if_family();
}
inline const ::std::string& ForwardingClassAccounting::if_family() const {
  // @@protoc_insertion_point(field_get:ForwardingClassAccounting.if_family)
  return if_family_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ForwardingClassAccounting::set_if_family(const ::std::string& value) {
  set_has_if_family();
  if_family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ForwardingClassAccounting.if_family)
}
inline void ForwardingClassAccounting::set_if_family(const char* value) {
  set_has_if_family();
  if_family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ForwardingClassAccounting.if_family)
}
inline void ForwardingClassAccounting::set_if_family(const char* value, size_t size) {
  set_has_if_family();
  if_family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ForwardingClassAccounting.if_family)
}
inline ::std::string* ForwardingClassAccounting::mutable_if_family() {
  set_has_if_family();
  // @@protoc_insertion_point(field_mutable:ForwardingClassAccounting.if_family)
  return if_family_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ForwardingClassAccounting::release_if_family() {
  clear_has_if_family();
  return if_family_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ForwardingClassAccounting::set_allocated_if_family(::std::string* if_family) {
  if (if_family != NULL) {
    set_has_if_family();
  } else {
    clear_has_if_family();
  }
  if_family_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), if_family);
  // @@protoc_insertion_point(field_set_allocated:ForwardingClassAccounting.if_family)
}

// optional uint32 fc_number = 2;
inline bool ForwardingClassAccounting::has_fc_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ForwardingClassAccounting::set_has_fc_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ForwardingClassAccounting::clear_has_fc_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ForwardingClassAccounting::clear_fc_number() {
  fc_number_ = 0u;
  clear_has_fc_number();
}
inline ::google::protobuf::uint32 ForwardingClassAccounting::fc_number() const {
  // @@protoc_insertion_point(field_get:ForwardingClassAccounting.fc_number)
  return fc_number_;
}
inline void ForwardingClassAccounting::set_fc_number(::google::protobuf::uint32 value) {
  set_has_fc_number();
  fc_number_ = value;
  // @@protoc_insertion_point(field_set:ForwardingClassAccounting.fc_number)
}

// optional uint64 if_pkts = 3;
inline bool ForwardingClassAccounting::has_if_pkts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ForwardingClassAccounting::set_has_if_pkts() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ForwardingClassAccounting::clear_has_if_pkts() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ForwardingClassAccounting::clear_if_pkts() {
  if_pkts_ = GOOGLE_ULONGLONG(0);
  clear_has_if_pkts();
}
inline ::google::protobuf::uint64 ForwardingClassAccounting::if_pkts() const {
  // @@protoc_insertion_point(field_get:ForwardingClassAccounting.if_pkts)
  return if_pkts_;
}
inline void ForwardingClassAccounting::set_if_pkts(::google::protobuf::uint64 value) {
  set_has_if_pkts();
  if_pkts_ = value;
  // @@protoc_insertion_point(field_set:ForwardingClassAccounting.if_pkts)
}

// optional uint64 if_octets = 4;
inline bool ForwardingClassAccounting::has_if_octets() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ForwardingClassAccounting::set_has_if_octets() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ForwardingClassAccounting::clear_has_if_octets() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ForwardingClassAccounting::clear_if_octets() {
  if_octets_ = GOOGLE_ULONGLONG(0);
  clear_has_if_octets();
}
inline ::google::protobuf::uint64 ForwardingClassAccounting::if_octets() const {
  // @@protoc_insertion_point(field_get:ForwardingClassAccounting.if_octets)
  return if_octets_;
}
inline void ForwardingClassAccounting::set_if_octets(::google::protobuf::uint64 value) {
  set_has_if_octets();
  if_octets_ = value;
  // @@protoc_insertion_point(field_set:ForwardingClassAccounting.if_octets)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_logical_5fport_2eproto__INCLUDED
